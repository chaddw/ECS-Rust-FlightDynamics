//This main file sets up the ECS architecture, creates the Entity, and runs the main simulation loop

//FlightGear is ran with this line of command argumments on the fgfs executable:
//fgfs.exe --aircraft=ufo --disable-panel --disable-sound --enable-hud --disable-random-objects --fdm=null --timeofday=noon --native-fdm=socket,in,30,,5500,udp

//Cessna Skyhawk visual
//fgfs.exe --disable-panel --disable-sound --enable-hud --disable-random-objects --fdm=null --timeofday=noon --native-fdm=socket,in,30,,5500,udp

//SPECS
use specs::prelude::*;

//Networking
use std::net::UdpSocket;

//Special global variables
#[macro_use]
extern crate lazy_static;

//Main loop
use std::{thread, time};

//Import Components and resources
mod data;

//Components
use crate::data::KeyboardState;
use crate::data::Packet;
use crate::data::DataFDM;

//Structures inside Components
use crate::data::PointMass;

//Resources
use crate::data::DeltaTime;
use crate::data::MaxThrust;
use crate::data::DeltaThrust;

//Import Systems
mod equations_of_motion;
mod flight_control;
mod make_packet;
mod send_packet;

//Import Vector, Matrix, Quaternion module
mod common;

//Import calculate mass properties function for use when the airplane Entity is created
use crate::equations_of_motion::calc_airplane_mass_properties;

//Macro to define special global variables
//Failed in trying to get this socket to be a resource because UdpSocket does not implement default
lazy_static!
{
    //Create socket
    static ref SOCKET: std::net::UdpSocket = UdpSocket::bind("127.0.0.1:1337").expect("couldn't bind to address");
    //Define earth ellipsoid
   // static ref ELLIPSOID: coord_transforms::structs::geo_ellipsoid::geo_ellipsoid = geo_ellipsoid::geo_ellipsoid::new(geo_ellipsoid::WGS84_SEMI_MAJOR_AXIS_METERS, geo_ellipsoid::WGS84_FLATTENING);
}


fn main()
{
    //Create world
    let mut world = World::new();

    //Register the Components to the world
    world.register::<DataFDM>();
    world.register::<KeyboardState>();
    world.register::<Packet>();

    //Choose frame rate, which will calculate delta time
    let frame_rate: f32 = 30.0;
    let dt: f32 = 1.0 / frame_rate; //seconds

    //Add dt as a SPECS resource
    world.insert(DeltaTime(dt));

    //Choose max thrust potential and increment amount
    let max_thrust: f32 = 3000.0;
    let d_thrust: f32 = 100.0;

    //Add max_thrust and d_thrust as resources
    world.insert(MaxThrust(max_thrust));
    world.insert(DeltaThrust(d_thrust));

    //Create variable to keep track of time elapsed
    let mut current_time: f32 = 0.0;
    let mut current_frame_main: usize = 0;

    //Create a dispatcher to manage system execution
    let mut dispatcher = DispatcherBuilder::new()
    .with(flight_control::FlightControl, "flightcontrol", &[])
    .with(equations_of_motion::EquationsOfMotion, "EOM", &[])
    .with(make_packet::MakePacket, "makepacket", &[])
    .with(send_packet::SendPacket, "sendpacket", &[])
    .build();
    dispatcher.setup(&mut world);

    //Intialize the airplane

    //Setup airplane with default values and then fill in what we need to calculate mass properties
    let mut myairplane = DataFDM{..Default::default()};

    //Lat lon coordinates of wpafb runway according to FlightGear is: 39.826, -84.045. Elevation 823 feet (248 meters)
    //These odd lat/lon coordinates were generated by going from converting ecef to lat/lon. Whereas the "real" lat/lon coordinates are: 39.826, -84.045

    //Wpafb (KFFO) runway ground level geodetic coordinates
    // myairplane.v_position.x = 0.6951355515021288;
    // myairplane.v_position.y = -1.4668619698501122;
    // myairplane.v_position.z = 248.0; //elevation is 823 ft... this is taken into account for when gravity is applied

    //Wpafb lat/lon/alt geodetic coordinates at 2000 ft (609 meters)
    myairplane.v_position.x = 0.6951355515021288;
    myairplane.v_position.y = -1.4668619698501122;
    myairplane.v_position.z = 857.0; //elevation is 823 ft... this is taken into account for when gravity is applied

    //Wpafb ecef coords at 248 ft elevation start
    // myairplane.v_position.x = 508911.187988474;
    // myairplane.v_position.y =  -4878823.54583204;
    // myairplane.v_position.z =   4063325.79612493;

    //Wpafb ecef coords at 609 elevation start 
    // myairplane.v_position.x =  508939.999272844;
    // myairplane.v_position.y =  -4879099.75350027;
    // myairplane.v_position.z =    4063557.38583521;

    //Test start position (same as c++ version)
    // myairplane.v_position.x = -5000.0;
    // myairplane.v_position.y = 0.0;
    // myairplane.v_position.z = 2000.0; 

    myairplane.v_velocity.x = 60.0;
    myairplane.f_speed = 60.0;
    myairplane.v_forces.x = 500.0;
    myairplane.thrustforce = 500.0;
    myairplane.q_orientation = common::Myquaternion::make_q_from_euler(0.0, 0.0, 0.0);
    myairplane.element = vec![
        PointMass{f_mass: 6.56, v_d_coords: common::Myvec::new(14.5, 12.0, 2.5), v_local_inertia: common::Myvec::new(13.92, 10.50, 24.00), f_incidence: -3.5, f_dihedral: 0.0, f_area: 31.2, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 7.31, v_d_coords: common::Myvec::new(14.5, 5.5, 2.5), v_local_inertia: common::Myvec::new(21.95, 12.22, 33.67), f_incidence: -3.5, f_dihedral: 0.0, f_area: 36.4, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 7.31, v_d_coords: common::Myvec::new(14.5, -5.5, 2.5), v_local_inertia: common::Myvec::new(21.95, 12.22, 33.67), f_incidence: -3.5, f_dihedral: 0.0, f_area: 36.4, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 6.56, v_d_coords: common::Myvec::new(14.5, -12.0, 2.5), v_local_inertia: common::Myvec::new(13.92, 10.50, 24.00), f_incidence: -3.5, f_dihedral: 0.0, f_area: 31.2, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 2.62, v_d_coords: common::Myvec::new(3.03, 2.5, 3.0), v_local_inertia: common::Myvec::new(0.837, 0.385, 1.206), f_incidence: 0.0, f_dihedral: 0.0, f_area: 10.8, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 2.62, v_d_coords: common::Myvec::new(3.03, -2.5, 3.0), v_local_inertia: common::Myvec::new(0.837, 0.385, 1.206), f_incidence: 0.0, f_dihedral: 0.0, f_area: 10.8, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 2.93, v_d_coords: common::Myvec::new(2.25, 0.0, 5.0), v_local_inertia: common::Myvec::new(1.262, 1.942, 0.718), f_incidence: 0.0, f_dihedral: 90.0, f_area: 12.0, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) },
        PointMass{f_mass: 31.8, v_d_coords: common::Myvec::new(15.25, 0.0, 1.5), v_local_inertia: common::Myvec::new(66.30, 861.9, 861.9), f_incidence: 0.0, f_dihedral: 0.0, f_area: 84.0, i_flap: 0, v_normal: common::Myvec::new(0.0, 0.0, 0.0), v_cg_coords: common::Myvec::new(0.0, 0.0, 0.0) }
        ];


    //Calculate mass properties on this airplane
    calc_airplane_mass_properties(&mut myairplane);

    //Create plane Entity and populate with the Component data using the data from myairplane 
    let _plane = world.create_entity()
    .with(DataFDM{
        mass: myairplane.mass,
        m_inertia: myairplane.m_inertia,
        m_inertia_inverse: myairplane.m_inertia_inverse,
        v_position: myairplane.v_position,       
        v_velocity: myairplane.v_velocity,      
        v_euler_angles: myairplane.v_euler_angles, 
        f_speed: myairplane.f_speed,
        v_angular_velocity: myairplane.v_angular_velocity,      
        v_forces: myairplane.v_forces,        
        thrustforce: myairplane.thrustforce, 
        v_moments: myairplane.v_moments,
        v_velocity_body: myairplane.v_velocity_body,     
        stalling: false,
        flaps: false,
        q_orientation: myairplane.q_orientation, 
        element: myairplane.element,
        current_frame: 0,
    })
    .with(KeyboardState{
        thrust_up: false,
        thrust_down: false,
        left_rudder: false,
        right_rudder: false,
        roll_left: false,
        roll_right: false,
        pitch_up: false,
        pitch_down: false,
        flaps_down: false,
        zero_flaps: false,
    })
    .with(Packet{
        ..Default::default()
    })
    .build();


    //Connect to the socket on FlightGear
    SOCKET.connect("127.0.0.1:5500").expect("connect function failed");

    //Create time type with the desired DT in milliseconds
    let timestep = time::Duration::from_millis((dt * 1000.0) as u64);

    //Main simulation loop
    loop 
    {
        //Get current time
        let start = time::Instant::now();

        //increment time count
        current_time = current_time + dt;
        current_frame_main = current_frame_main + 1;
        println!("{}", "====================================================");
        println!("time: {}, frames: {}", current_time, current_frame_main);


        //Process this frame
        dispatcher.dispatch(&world); 
        world.maintain();

        //Find difference in time elapsed this loop versus the timestep
        let sleep_time = timestep.checked_sub(time::Instant::now().duration_since(start));
        
        //Sleep for extra time if calculation took less time than the dt time step
        if sleep_time != None 
        {
            thread::sleep(sleep_time.unwrap());
        }
    
    }

}




